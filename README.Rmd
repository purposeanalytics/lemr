---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "80%",
  dpi = 300
)

options(tibble.max_extra_cols = 20)
ggplot2::theme_set(ggplot2::theme_minimal())
library(dplyr)
```

# lemur

CMHC Housing Supply Challenge Proof of Concept

## Installation

You can install lemur from GitHub:

``` r
# install.packages("devtools")
devtools::install_github("purposeanalytics/lemur")
```

The next section discusses usage of the package for _users_ of lemur. For information on the _development_, please skip ahead to the ["Development" section](#development).

## Usage

### App

The primary product of lemur is a Shiny app which will show low-end of market rental housing in Toronto, along with other data sets. To load the app, run:

```{r, eval = FALSE}
library(lemur)
run_app()
```

### Functions

lemur also contains a few utility functions.

#### geocode_address

For example, you can geocode addresses using the Bing geocoder:

```{r}
library(lemur)
geocode_address("220 Yonge St Toronto ON")
```

This looks up any address in Canada, so it's helpful to supply the city or postal code for the most accurate results - for example, 220 Yonge St without "Toronto ON" gives us somewhere on an island in Lake Huron:

```{r}
geocode_address("220 Yonge St")
```

An API token is required, and the function looks for it in the `BING_TOKEN` environment variable, but this can be changed or supplied directly via the `token` argument.

#### clean_neighbourhood_names

There is also a utility function to clean City of Toronto neighbourhood names, which often come attached with their neighbourhood numbers (e.g. "Danforth (66)") or inconcistent spacing:

```{r neighbourhood, cache = TRUE}
library(opendatatoronto)
library(dplyr)

to_neighbourhoods <- list_package_resources("https://open.toronto.ca/dataset/neighbourhoods/") %>%
  get_resource()

to_neighbourhoods

to_neighbourhoods %>%
  mutate(neighbourhood = clean_neighbourhood_names(AREA_NAME)) %>%
  select(AREA_NAME, neighbourhood)
```

If any of the neighbourhoods can't be cleaned, the function produces a warning with the mismatches, and returns all of the neighbourhoods that _can_ be cleaned, cleaned, with the mismatches in their original form:

```{r}
tibble(neighbourhood = c(
  "Cabbagetown-South St.James Town (71)",
  "Cabbagetown-South St. James Town (71)"
)) %>%
  mutate(neighbourhood = clean_neighbourhood_names(neighbourhood))
```


If you run into this warning, please give me a shout with the name of the neighbourhood you're trying to clean! This function will be reworked and expanded to handle all the strange spellings we can find :)

### Data sets

lemur contains a number of spatial data sets (used in the app), which can also be used in other code or packages.

#### toronto

toronto is a data set that includes the boundary of Toronto:

```{r map-toronto}
library(sf)
library(ggplot2)
toronto

p <- ggplot() +
  geom_sf(data = toronto)

p
```

#### neighbourhoods

neighbourhoods contains the 140 social planning neighbourhoods in Toronto and their boundaries. Once the [new 158 neighbourhoods](https://www.toronto.ca/city-government/data-research-maps/neighbourhoods-communities/neighbourhood-profiles/) are released by the City of Toronto, this data set will be updated.

```{r map-neighbourhoods}
neighbourhoods

p <- p +
  geom_sf(data = neighbourhoods)

p
```
 
#### apartment_building_registry

apartment_building_registry is a geocoded version of the City of Toronto's [Apartment Building Registration Dataset](https://open.toronto.ca/dataset/apartment-building-registration/), with cleaned addresses and latitude and longitude:

```{r map-apt}
apartment_building_registry

p +
  geom_point(data = apartment_building_registry, aes(x = bing_longitude, y = bing_latitude))
```

#### neighbourhood_profiles and city_profile

neighbourhood_profiles contains variables describing neighbourhoods in Toronto from the 2016 census. The data set is a list, with one element for each neighbourhood. Within each neighbourhood there is one element for each variable. To see a full description of the variables, see: `?neighbourhood_profiles`.

```{r neighbourhood-profiles}
names(neighbourhood_profiles[["Danforth"]])
```

You can compare these to the city values (in `city_profile`)

```{r city-profile}
names(city_profile)
```

using `plot_neighbourhood_profile()` to compare breakdowns:

```{r plot-household-size}
neighbourhood_profiles[["Danforth"]] %>%
  plot_neighbourhood_profile("household_size")
```

or `plot_neighbourhood_profile_distribution()` to compare a value to the distribution across the city:

```{r plot-unaffordable-housing}
neighbourhood_profiles[["Danforth"]] %>%
  plot_neighbourhood_profile_distribution("unaffordable_housing", binwidth = 0.01) + 
  ggplot2::scale_x_continuous(labels = scales::percent)
```

### address_points

address_points() contains the addresses and latitude / longitude for over 500,000 addresses in the City of Toronto. The data is in a SQLite database, so just calling `address_points()` returns a preview of the data:

```{r address-points}
address_points()
```

It can be filtered like a regular data frame, but results must be "returned" by calling `dplyr::collect()`:

```{r address-points-collect}
address_points() %>%
  filter(address == "100 Queen St W") %>%
  collect()
```

## Development

To add to lemur code or work within the package repository itself, first clone the repository and open the project in RStudio.

### renv

This package uses [`renv`](https://rstudio.github.io/renv/articles/renv.html) for managing dependencies during the _development_ of lemur and to ensure package versions stay consistent, on your own machine and across other machines. `renv` isolates dependencies so that e.g. the set of (and versions of) libraries used in the development of `lemur` can be different than the libraries used in your other analyses. 

This [article about collaborating with `renv`](https://rstudio.github.io/renv/articles/collaborating.html) outlines the steps for collaborating with `renv`. The setup has already been done, so the key is step #4 under "Collaborating with renv":

> When a collaborator first launches in this project, renv should automatically bootstrap itself, thereby downloading and installing the appropriate version of renv into the project library. After this has completed, they can then use `renv::restore()` to restore the project library locally on their machine.

So, fingers crossed, all you need to do is `renv::restore()` and `renv` will install all the correct packages and versions for you!

### Loading, developing, and updating code

The [`devtools`](https://devtools.r-lib.org) package is a package developer's best friend! It contains all the needed functions to load, document, test, etc a package.

In particular, `devtools::load_all()` "simulates installing and reloading your package", and so it loads all R code in `R/` as well as any data files in `data/`, allowing you to access all functions and data without really "installing" the package.

So to load the package and launch the app, you load the package, then use the `run_app()` function:

```{r, eval = FALSE}
devtools::load_all(".")
# â„¹ Loading lemur
run_app()
```

If you make changes to the app, or any other functions / data, just `devtools::load_all(".")` again and relaunch! Particularly useful is the _shortcut_ for `load_all()`, `control + shift + l` (that's an L), which is well-worked into my muscle memory :)
